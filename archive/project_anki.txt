# Contesto e Obiettivi del Progetto Tutoring

## 1. Obiettivo Finale

L'obiettivo principale del progetto è guidare uno studente di livello intermedio-avanzato (B2/C1) da una **comprensione passiva** della grammatica inglese a una **padronanza attiva e sicura**. 

Il problema centrale identificato è un conflitto tra l'istinto linguistico dello studente (sviluppato tramite l'esposizione alla lingua) e le regole grammaticali apprese in modo scorretto o incompleto. Questo porta a una performance incostante, specialmente con le strutture grammaticali più complesse.

## 2. Metodologia e Strumenti

Per affrontare questo problema, abbiamo sviluppato un ecosistema didattico strutturato per ogni argomento grammaticale. Il primo argomento che stiamo trattando è **"Il Congiuntivo" (The Subjunctive Mood)**.

L'ecosistema si basa su tre tipi di artefatti digitali:

1.  **Lezione Approfondita (HTML):** Un documento dettagliato che spiega la teoria, analizza gli errori specifici dello studente e fornisce un quadro completo dell'argomento.
2.  **Mazzo Appunti (HTML):** Una versione sintetica e schematica della lezione, progettata per facilitare la creazione di carte Anki da parte dello studente.
3.  **Esercizi Pratici (HTML):** Un'applicazione web interattiva per una sessione di pratica "una tantum", con salvataggio dei progressi.

## 3. Strategia Anki e Problema Tecnico Attuale

Il cuore della strategia a lungo termine è l'uso di Anki. L'obiettivo è creare mazzi di carte che testino la **comprensione della regola**, non la memorizzazione di frasi specifiche.

**La Sfida:**
Vogliamo creare un numero limitato di carte Anki (es. 5 per gruppo di esercizi) che, ogni volta che vengono studiate, presentino una domanda **scelta a caso** da un database più ampio.

**Cronistoria dei Tentativi e Approcci:**

1.  **Tentativo 1: Database JSON e JavaScript**
    * **Approccio:** La nostra prima idea è stata di usare uno script Python per creare una nota Anki per ogni gruppo di esercizi. Questa nota conteneva un campo `Database` con tutti gli esercizi del gruppo in formato JSON. Un codice JavaScript nel template della carta avrebbe dovuto leggere questo JSON, pescare una domanda a caso e mostrarla.
    * **Risultato:** Fallimento. Anki, per motivi di sicurezza o per come il template "Prettify" gestisce i campi, non eseguiva lo script correttamente. Invece di una domanda casuale, mostrava il testo grezzo del JSON o un messaggio di "Caricamento..." bloccato.

2.  **Tentativo 2: Approccio con Delimitatore (ispirato da una ricerca online)**
    * **Approccio:** Abbiamo semplificato il metodo. Invece di un complesso JSON, lo script Python creava tre campi (`Front_DB`, `Back_DB`, `Note_DB`). Ognuno conteneva una lunga stringa di testo con tutti i fronti (o retro, o note) di un gruppo, separati da un delimitatore unico (`|||`). Uno script JavaScript sulla carta avrebbe dovuto generare un singolo numero casuale (un indice) e usarlo per pescare l'elemento corrispondente da ciascuna delle tre "liste".
    * **Risultato:** Fallimento simile al precedente. Il problema di fondo è rimasto lo stesso: il template della carta non eseguiva correttamente lo script per processare le stringhe, mostrando nuovamente il contenuto grezzo dei campi.

3.  **Proposta Intermedia (Rifiutata): Cloze Deletion**
    * **Approccio Proposto:** Ho suggerito di usare la funzione nativa di Anki "Cloze Deletion". Lo script avrebbe creato una singola nota per mazzo, con ogni esercizio formattato come una cancellazione nascosta separata (c1, c2, c3...).
    * **Motivo del Rifiuto:** Hai giustamente sottolineato che questo approccio tradiva l'obiettivo principale. Anki avrebbe creato una carta individuale per ogni esercizio (es. 50 carte per il Mazzo 1), esponendo l'intero database allo studente e forzandolo a studiare ogni singola frase, tornando al problema della memorizzazione meccanica che volevamo evitare.

**Prossima Idea e Soluzione Proposta:**

La nostra analisi ha rivelato che il problema non risiede tanto nello script Python, che genera correttamente i dati, ma nel **template di Anki** e nel modo in cui interagisce con il codice che gli viene passato. Il continuo fallimento indica che i nostri tentativi di inserire logica complessa direttamente nei campi vengono bloccati.

L'approccio corretto deve quindi basarsi su una netta separazione tra dati e logica, utilizzando il metodo con delimitatore che è il più robusto.

1.  **Script Python (Confermato):** Useremo l'ultima versione dello script che crea note con i tre campi `Front_DB`, `Back_DB`, `Note_DB`, popolati con le stringhe separate dal delimitatore `|||`.
2.  **Template Anki (Da Implementare Correttamente):** La chiave è inserire manualmente il codice JavaScript corretto direttamente nei template del tipo di nota in Anki, una volta importato il mazzo.
    * **Template Fronte:** Conterrà il codice per leggere i database, generare l'indice casuale e mostrarlo.
    * **Template Retro:** Conterrà il codice per recuperare l'indice e mostrare retro e nota corrispondenti.
3.  **Flusso di Lavoro:** Il passo cruciale sarà: eseguire lo script Python, importare il file `.apkg` in Anki, e **immediatamente dopo** aprire l'editor dei tipi di nota per copiare e incollare i template HTML/JavaScript corretti, assicurandosi che Anki usi la logica più aggiornata. Questo eviterà problemi di cache o di mancato aggiornamento dei template.
